{% extends "base.html" %}

{% block title %}Movie Recommendations - Plex Movie Selector{% endblock %}

{% block content %}
<div class="recommendation-container">
    <div class="filters-section">
        <h2>Filter Options</h2>

        <!-- Last Watched Movie Display -->
        <div id="last-watched-container" style="display: none;">
            <div class="last-watched-movie">
                <h3>Last Watched</h3>
                <div class="last-watched-content">
                    <img id="last-watched-poster" src="" alt="Last Watched" class="last-watched-poster">
                    <div class="last-watched-info">
                        <div id="last-watched-title" class="last-watched-title"></div>
                        <div id="last-watched-year" class="last-watched-year"></div>
                    </div>
                </div>
            </div>
        </div>

        <form id="filters-form">
            <div class="filter-group">
                <label>
                    <input type="checkbox" id="exclude_watched" checked>
                    Exclude Watched Movies
                </label>
            </div>

            <div class="filter-group">
                <label for="filter_decade">Filter by Decade</label>
                <select id="filter_decade">
                    <option value="">All Decades</option>
                    <option value="1950s">1950s</option>
                    <option value="1960s">1960s</option>
                    <option value="1970s">1970s</option>
                    <option value="1980s">1980s</option>
                    <option value="1990s">1990s</option>
                    <option value="2000s">2000s</option>
                    <option value="2010s">2010s</option>
                    <option value="2020s">2020s</option>
                </select>
            </div>

            <!-- Actor Filters Group (only shown when last watched is available) -->
            <div id="actor-filters-group" style="display: none;">
                <div class="filter-section-header">Actor Filters</div>

                <div class="filter-group">
                    <label>
                        <input type="checkbox" id="exclude_same_actors">
                        Movies with Actors from Last Watched
                    </label>
                    <div id="linked-actors-display" class="linked-info" style="display: none;">
                        <small>Linked actors: <span id="linked-actors-list"></span></small>
                    </div>
                </div>

                <div class="filter-divider">OR</div>

                <div class="filter-group" id="specific-actor-group">
                    <label for="filter_actor">Filter by Specific Actor</label>
                    <input type="text" id="filter_actor" placeholder="Enter actor name">
                </div>
            </div>

            <!-- Director Filter (only shown when last watched is available) -->
            <div id="director-filter-group" style="display: none;">
                <div class="filter-section-header">Director Filter</div>

                <div class="filter-group">
                    <label>
                        <input type="checkbox" id="exclude_same_director">
                        Movies with Director from Last Watched
                    </label>
                    <div id="linked-directors-display" class="linked-info" style="display: none;">
                        <small>Linked directors: <span id="linked-directors-list"></span></small>
                    </div>
                </div>
            </div>
        </form>
    </div>

    <div class="recommendation-section">
        <div id="loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Finding your perfect movie...</p>
        </div>

        <div id="no-recommendation" class="no-recommendation" style="display: none;">
            <h2>No Movies Available</h2>
            <p id="no-recommendation-message">Click "Get Recommendation" to find a movie</p>
        </div>

        <div id="movie-card" class="movie-card" style="display: none;">
            <div class="movie-poster">
                <img id="movie-poster-img" src="" alt="Movie Poster">
            </div>
            <div class="movie-details">
                <h2 id="movie-title"></h2>
                <div class="movie-meta">
                    <span id="movie-year"></span>
                    <span class="separator">‚Ä¢</span>
                    <span id="movie-rating" class="rating"></span>
                </div>
                <p id="movie-summary" class="movie-summary"></p>
                <div class="movie-credits">
                    <p><strong>Director:</strong> <span id="movie-directors"></span></p>
                    <p><strong>Cast:</strong> <span id="movie-actors"></span></p>
                </div>
                <div class="movie-actions">
                    <button id="play-btn" class="btn btn-primary">Play Movie</button>
                    <button id="pass-btn" class="btn btn-secondary">Pass</button>
                    <button id="next-btn" class="btn btn-secondary">Get Another Recommendation</button>
                </div>
            </div>
        </div>

        <div id="initial-state" class="initial-state">
            <h2>Ready to Find Your Next Movie?</h2>
            <p>Configure your filters and get a personalized recommendation</p>
            <button id="get-recommendation-btn" class="btn btn-primary btn-large">Get Recommendation</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let currentMovie = null;
let lastWatchedMovie = null;
let selectedClient = null;

// Load preferences and last watched on page load
document.addEventListener('DOMContentLoaded', async () => {
    await loadPreferences();
    await loadLastWatched();
    await loadSelectedClient();
    setupFilterListeners();
    updatePlayButtonState();
});

async function loadPreferences() {
    try {
        const response = await fetch('/api/preferences');
        const data = await response.json();

        if (data.success) {
            const prefs = data.preferences;
            document.getElementById('exclude_watched').checked = prefs.exclude_watched;
            document.getElementById('exclude_same_actors').checked = prefs.exclude_same_actors;
            document.getElementById('exclude_same_director').checked = prefs.exclude_same_director;
            document.getElementById('filter_decade').value = prefs.filter_decade || '';
            document.getElementById('filter_actor').value = prefs.filter_actor || '';

            // Update linked actors/directors display
            updateLinkedInfoDisplay();
        }
    } catch (error) {
        console.error('Error loading preferences:', error);
    }
}

async function loadLastWatched() {
    try {
        const response = await fetch('/api/last-watched');
        const data = await response.json();

        if (data.success && data.movie) {
            lastWatchedMovie = data.movie;
            displayLastWatched(data.movie);
            // Show actor and director filter groups
            document.getElementById('actor-filters-group').style.display = 'block';
            document.getElementById('director-filter-group').style.display = 'block';
        }
    } catch (error) {
        console.error('Error loading last watched:', error);
    }
}

async function loadSelectedClient() {
    try {
        const response = await fetch('/api/selected-client');
        const data = await response.json();

        if (data.success && data.client) {
            selectedClient = data.client;
        } else {
            selectedClient = null;
        }
    } catch (error) {
        console.error('Error loading selected client:', error);
        selectedClient = null;
    }
}

function updatePlayButtonState() {
    const playButton = document.getElementById('play-btn');

    if (!selectedClient) {
        // No client selected - grey out and disable
        playButton.disabled = true;
        playButton.style.opacity = '0.5';
        playButton.style.cursor = 'not-allowed';
        playButton.title = 'Please select a playback client in the Plex Clients page';
    } else {
        // Client selected - enable
        playButton.disabled = false;
        playButton.style.opacity = '1';
        playButton.style.cursor = 'pointer';
        playButton.title = `Play on ${selectedClient.name}`;
    }
}

function displayLastWatched(movie) {
    document.getElementById('last-watched-container').style.display = 'block';
    document.getElementById('last-watched-title').textContent = movie.title;
    document.getElementById('last-watched-year').textContent = movie.year || '';
    if (movie.poster) {
        document.getElementById('last-watched-poster').src = movie.poster;
    }
}

function setupFilterListeners() {
    // Handle mutual exclusivity between actor filters
    const actorCheckbox = document.getElementById('exclude_same_actors');
    const specificActorInput = document.getElementById('filter_actor');

    actorCheckbox.addEventListener('change', () => {
        if (actorCheckbox.checked) {
            specificActorInput.value = '';
            specificActorInput.disabled = true;
            updateLinkedInfoDisplay();
        } else {
            specificActorInput.disabled = false;
            updateLinkedInfoDisplay();
        }
    });

    specificActorInput.addEventListener('input', () => {
        if (specificActorInput.value.trim()) {
            actorCheckbox.checked = false;
            actorCheckbox.disabled = true;
            updateLinkedInfoDisplay();
        } else {
            actorCheckbox.disabled = false;
        }
    });

    // Update linked info when director checkbox changes
    document.getElementById('exclude_same_director').addEventListener('change', updateLinkedInfoDisplay);
}

function updateLinkedInfoDisplay() {
    if (!lastWatchedMovie) return;

    // Show/hide linked actors
    const actorCheckbox = document.getElementById('exclude_same_actors');
    const linkedActorsDisplay = document.getElementById('linked-actors-display');
    const linkedActorsList = document.getElementById('linked-actors-list');

    if (actorCheckbox.checked && lastWatchedMovie.actors && lastWatchedMovie.actors.length > 0) {
        linkedActorsDisplay.style.display = 'block';
        linkedActorsList.textContent = lastWatchedMovie.actors.join(', ');
    } else {
        linkedActorsDisplay.style.display = 'none';
    }

    // Show/hide linked directors
    const directorCheckbox = document.getElementById('exclude_same_director');
    const linkedDirectorsDisplay = document.getElementById('linked-directors-display');
    const linkedDirectorsList = document.getElementById('linked-directors-list');

    if (directorCheckbox.checked && lastWatchedMovie.directors && lastWatchedMovie.directors.length > 0) {
        linkedDirectorsDisplay.style.display = 'block';
        linkedDirectorsList.textContent = lastWatchedMovie.directors.join(', ');
    } else {
        linkedDirectorsDisplay.style.display = 'none';
    }
}

async function savePreferences() {
    const preferences = {
        exclude_watched: document.getElementById('exclude_watched').checked,
        exclude_same_actors: document.getElementById('exclude_same_actors').checked,
        exclude_same_director: document.getElementById('exclude_same_director').checked,
        filter_decade: document.getElementById('filter_decade').value,
        filter_actor: document.getElementById('filter_actor').value
    };

    try {
        await fetch('/api/preferences', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(preferences)
        });
    } catch (error) {
        console.error('Error saving preferences:', error);
    }
}

async function getRecommendation() {
    showLoading();

    try {
        // Save current filter preferences before getting recommendation
        await savePreferences();

        const response = await fetch('/api/recommend');
        const data = await response.json();

        if (response.ok && data.success) {
            currentMovie = data.movie;
            displayMovie(data.movie);
        } else {
            showNoRecommendation(data.error || 'No movies found matching your criteria');
        }
    } catch (error) {
        showNoRecommendation('An error occurred. Please try again.');
    }
}

function displayMovie(movie) {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('no-recommendation').style.display = 'none';
    document.getElementById('initial-state').style.display = 'none';
    document.getElementById('movie-card').style.display = 'flex';

    document.getElementById('movie-title').textContent = movie.title;
    document.getElementById('movie-year').textContent = movie.year || 'Unknown';
    document.getElementById('movie-rating').textContent = `‚≠ê ${movie.rating.toFixed(1)}/10`;
    document.getElementById('movie-summary').textContent = movie.summary || 'No summary available';
    document.getElementById('movie-directors').textContent = movie.directors.join(', ') || 'Unknown';
    document.getElementById('movie-actors').textContent = movie.actors.join(', ') || 'Unknown';

    // Set poster if available
    if (movie.poster) {
        document.getElementById('movie-poster-img').src = movie.poster;
    }

    // Update play button state based on selected client
    updatePlayButtonState();
}

function showLoading() {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('no-recommendation').style.display = 'none';
    document.getElementById('initial-state').style.display = 'none';
    document.getElementById('movie-card').style.display = 'none';
}

function showNoRecommendation(message) {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('no-recommendation').style.display = 'block';
    document.getElementById('no-recommendation-message').textContent = message;
    document.getElementById('initial-state').style.display = 'none';
    document.getElementById('movie-card').style.display = 'none';
}

async function playMovie() {
    if (!currentMovie) return;

    const playBtn = document.getElementById('play-btn');
    const originalText = playBtn.textContent;
    playBtn.disabled = true;
    playBtn.textContent = 'Playing...';

    try {
        const response = await fetch('/api/play', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ rating_key: currentMovie.rating_key })
        });

        const data = await response.json();

        if (data.success) {
            // Successful playback
            const methodMsg = data.method === 'playqueue'
                ? 'Playback started via PlayQueue!'
                : 'Playback command sent to client!';
            showPlaybackMessage(methodMsg, 'success', data.deep_link);
        } else {
            // Playback failed - show deep link fallback
            if (data.deep_link) {
                showPlaybackMessage(
                    data.error || 'Could not start playback automatically.',
                    'fallback',
                    data.deep_link
                );
            } else {
                alert(data.error || 'Failed to play movie. Please try again.');
            }
        }
    } catch (error) {
        alert('An error occurred while trying to play the movie. Please check your connection and try again.');
    } finally {
        playBtn.disabled = false;
        playBtn.textContent = originalText;
    }
}

function showPlaybackMessage(message, type, deepLink) {
    // Create a modal-style message
    const existingModal = document.getElementById('playback-modal');
    if (existingModal) {
        existingModal.remove();
    }

    const modal = document.createElement('div');
    modal.id = 'playback-modal';
    modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 30px;
        border-radius: 10px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        max-width: 500px;
        width: 90%;
    `;

    let content = `
        <div style="text-align: center;">
            <p style="font-size: 16px; margin-bottom: 20px; color: #333;">
                ${message}
            </p>
    `;

    if (type === 'fallback' && deepLink) {
        content += `
            <p style="margin-bottom: 15px; font-size: 14px; color: #666;">
                Click the link below to open this movie in your Plex app:
            </p>
            <a href="${deepLink}"
               style="display: block; padding: 15px 25px; background: #e5a00d; color: white;
                      text-decoration: none; border-radius: 5px; font-weight: bold; margin-bottom: 15px;"
               target="_blank">
                üì± Open in Plex App
            </a>
            <p style="font-size: 12px; color: #999; margin-bottom: 15px;">
                (On mobile, this will open directly in your Plex app)
            </p>
        `;
    } else if (deepLink) {
        content += `
            <p style="margin-top: 10px; font-size: 12px; color: #666;">
                <a href="${deepLink}" style="color: #e5a00d;" target="_blank">
                    Or click here to open in Plex app manually
                </a>
            </p>
        `;
    }

    content += `
            <button onclick="document.getElementById('playback-modal').remove()"
                    style="padding: 10px 30px; background: #555; color: white; border: none;
                           border-radius: 5px; cursor: pointer; font-size: 14px;">
                Close
            </button>
        </div>
    `;

    modal.innerHTML = content;
    document.body.appendChild(modal);

    // Add backdrop
    const backdrop = document.createElement('div');
    backdrop.id = 'playback-backdrop';
    backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
    `;
    backdrop.onclick = () => {
        modal.remove();
        backdrop.remove();
    };
    document.body.appendChild(backdrop);
}

async function passMovie() {
    if (!currentMovie) return;

    try {
        const response = await fetch('/api/pass', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                rating_key: currentMovie.rating_key,
                title: currentMovie.title
            })
        });

        const data = await response.json();

        if (data.success) {
            // Get next recommendation
            getRecommendation();
        } else {
            alert('Failed to pass movie: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        alert('An error occurred. Please try again.');
    }
}

// Event listeners
document.getElementById('get-recommendation-btn').addEventListener('click', getRecommendation);
document.getElementById('next-btn').addEventListener('click', getRecommendation);
document.getElementById('play-btn').addEventListener('click', playMovie);
document.getElementById('pass-btn').addEventListener('click', passMovie);
</script>
{% endblock %}
